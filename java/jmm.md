# Java内存模型

## 简介
JMM 的主要目标是 定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节  
JMM 规定了所有的变量都存储在主内存（Main Memory）中。  
每条线程还有自己的工作内存（Working Memory），工作内存中保留了该线程使用到的变量的主内存的副本。工作内存是 JMM 的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。  
内存屏障处理指令重排问题

## volatile
### 特性
* 保证变量对所有线程的可见性。
* 禁止进行指令重排序

#### 语义1 确保所有线程可见性
**线程写 volatile 变量的过程**
* 改变线程工作内存中 volatile 变量副本的值
* 将改变后的副本的值从工作内存刷新到主内存

**线程读 volatile 变量的过程**

* 从主内存中读取 volatile 变量的最新值到线程的工作内存中
* 从工作内存中读取 volatile 变量的副本

volatile不确保线程安全，如下情况才能确保线程安全
```shell script
运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
变量不需要与其他状态变量共同参与不变约束。
```

#### 语义2 禁止进行指令重排序
* 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
* 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。
## synchronized
基于锁实现，编译期间将锁标识写入字节码，告诉jvm这边是一个同步方法，在进入该方法之前先获取相应的锁，锁的计数器加1，方法结束后计数器-1，如果获取失败就阻塞住，知道该锁被释放。
## 参考
* https://dunwu.github.io/javacore/concurrent/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html
* https://zhuanlan.zhihu.com/p/75880892